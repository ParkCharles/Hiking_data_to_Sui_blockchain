(()=>{var e={364:e=>{"use strict";e.exports=function(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var n=0;n<e.length;n++){var i=e.charAt(n),s=i.charCodeAt(0);if(255!==t[s])throw new TypeError(i+" is ambiguous");t[s]=n}var a=e.length,o=e.charAt(0),c=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function d(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;for(var r=0,n=0,i=0;e[r]===o;)n++,r++;for(var s=(e.length-r)*c+1>>>0,u=new Uint8Array(s);e[r];){var d=t[e.charCodeAt(r)];if(255===d)return;for(var l=0,h=s-1;(0!==d||l<i)&&-1!==h;h--,l++)d+=a*u[h]>>>0,u[h]=d%256>>>0,d=d/256>>>0;if(0!==d)throw new Error("Non-zero carry");i=l,r++}for(var p=s-i;p!==s&&0===u[p];)p++;for(var f=new Uint8Array(n+(s-p)),m=n;p!==s;)f[m++]=u[p++];return f}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,i=0,s=t.length;i!==s&&0===t[i];)i++,r++;for(var c=(s-i)*u+1>>>0,d=new Uint8Array(c);i!==s;){for(var l=t[i],h=0,p=c-1;(0!==l||h<n)&&-1!==p;p--,h++)l+=256*d[p]>>>0,d[p]=l%a>>>0,l=l/a>>>0;if(0!==l)throw new Error("Non-zero carry");n=h,i++}for(var f=c-n;f!==c&&0===d[f];)f++;for(var m=o.repeat(r);f<c;++f)m+=e.charAt(d[f]);return m},decodeUnsafe:d,decode:function(e){var t=d(e);if(t)return t;throw new Error("Non-base"+a+" character")}}}},763:(e,t,r)=>{const n=r(364);e.exports=n("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var s=t[n]={exports:{}};return e[n](s,s.exports,r),s.exports}(()=>{"use strict";function e(e){return Uint8Array.from(atob(e),(e=>e.charCodeAt(0)))}const t=8192;function n(e){if(e.length<t)return btoa(String.fromCharCode(...e));let r="";for(var n=0;n<e.length;n+=t){const i=e.slice(n,n+t);r+=String.fromCharCode(...i)}return btoa(r)}var i=r(763);const s=e=>i.encode(e),a=e=>i.decode(e);function o(e){const t=e.startsWith("0x")?e.slice(2):e,r=t.length%2==0?t:`0${t}}`,n=r.match(/.{2}/g)?.map((e=>parseInt(e,16)))??[];return Uint8Array.from(n)}function c(e){return e.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),"")}function u(e){let t=[],r=0;if(0===e)return[0];for(;e>0;)t[r]=127&e,(e>>=7)&&(t[r]|=128),r+=1;return t}class d{constructor(e){this.bytePosition=0,this.dataView=new DataView(e.buffer)}shift(e){return this.bytePosition+=e,this}read8(){let e=this.dataView.getUint8(this.bytePosition);return this.shift(1),e}read16(){let e=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),e}read32(){let e=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),e}read64(){let e=this.read32(),t=this.read32().toString(16)+e.toString(16).padStart(8,"0");return BigInt("0x"+t).toString(10)}read128(){let e=BigInt(this.read64()),t=BigInt(this.read64()).toString(16)+e.toString(16).padStart(16,"0");return BigInt("0x"+t).toString(10)}read256(){let e=BigInt(this.read128()),t=BigInt(this.read128()).toString(16)+e.toString(16).padStart(32,"0");return BigInt("0x"+t).toString(10)}readBytes(e){let t=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,t,e);return this.shift(e),r}readULEB(){let e=this.bytePosition+this.dataView.byteOffset,t=new Uint8Array(this.dataView.buffer,e),{value:r,length:n}=function(e){let t=0,r=0,n=0;for(;;){let i=e[n];if(n+=1,t|=(127&i)<<r,!(128&i))break;r+=7}return{value:t,length:n}}(t);return this.shift(n),r}readVec(e){let t=this.readULEB(),r=[];for(let n=0;n<t;n++)r.push(e(this,n,t));return r}}function l(e,t=["<",">"]){const[r,n]=t,i=[];let s="",a=0;for(let t=0;t<e.length;t++){const o=e[t];o===r&&a++,o===n&&a--,0!==a||","!==o?s+=o:(i.push(s.trim()),s="")}return i.push(s.trim()),i}class h{constructor({size:e=1024,maxSize:t,allocateSize:r=1024}={}){this.bytePosition=0,this.size=e,this.maxSize=t||e,this.allocateSize=r,this.dataView=new DataView(new ArrayBuffer(e))}ensureSizeOrGrow(e){const t=this.bytePosition+e;if(t>this.size){const e=Math.min(this.maxSize,this.size+this.allocateSize);if(t>e)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`);this.size=e;const r=new ArrayBuffer(this.size);new Uint8Array(r).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(r)}}shift(e){return this.bytePosition+=e,this}write8(e){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(e)),this.shift(1)}write16(e){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(e),!0),this.shift(2)}write32(e){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(e),!0),this.shift(4)}write64(e){return p(BigInt(e),8).forEach((e=>this.write8(e))),this}write128(e){return p(BigInt(e),16).forEach((e=>this.write8(e))),this}write256(e){return p(BigInt(e),32).forEach((e=>this.write8(e))),this}writeULEB(e){return u(e).forEach((e=>this.write8(e))),this}writeVec(e,t){return this.writeULEB(e.length),Array.from(e).forEach(((r,n)=>t(this,r,n,e.length))),this}*[Symbol.iterator](){for(let e=0;e<this.bytePosition;e++)yield this.dataView.getUint8(e);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(e){return function(e,t){switch(t){case"base58":return s(e);case"base64":return n(e);case"hex":return c(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}(this.toBytes(),e)}}function p(e,t){let r=new Uint8Array(t),n=0;for(;e>0;)r[n]=Number(e%BigInt(256)),e/=BigInt(256),n+=1;return r}var f,m,g,y,w=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},b=(e,t,r)=>(w(e,t,"read from private field"),r?r.call(e):t.get(e)),v=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},S=(e,t,r,n)=>(w(e,t,"write to private field"),n?n.call(e,r):t.set(e,r),r);const T=class{constructor(e){v(this,f,void 0),v(this,m,void 0),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),S(this,f,e.write),S(this,m,e.serialize??((e,t)=>{const r=new h({size:this.serializedSize(e)??void 0,...t});return b(this,f).call(this,e,r),r.toBytes()})),this.validate=e.validate??(()=>{})}write(e,t){this.validate(e),b(this,f).call(this,e,t)}serialize(e,t){return this.validate(e),new k(this,b(this,m).call(this,e,t))}parse(e){const t=new d(e);return this.read(t)}transform({name:e,input:t,output:r}){return new T({name:e??this.name,read:e=>r(this.read(e)),write:(e,r)=>b(this,f).call(this,t(e),r),serializedSize:e=>this.serializedSize(t(e)),serialize:(e,r)=>b(this,m).call(this,t(e),r),validate:e=>this.validate(t(e))})}};let E=T;f=new WeakMap,m=new WeakMap;const x=Symbol.for("@mysten/serialized-bcs");class k{constructor(e,t){v(this,g,void 0),v(this,y,void 0),S(this,g,e),S(this,y,t)}get[x](){return!0}toBytes(){return b(this,y)}toHex(){return c(b(this,y))}toBase64(){return n(b(this,y))}toBase58(){return s(b(this,y))}parse(){return b(this,g).parse(b(this,y))}}function A({size:e,...t}){return new E({...t,serializedSize:()=>e})}function I({readMethod:e,writeMethod:t,...r}){return A({...r,read:t=>t[e](),write:(e,r)=>r[t](e),validate:e=>{if(e<0||e>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${e}. Expected value in range 0-${r.maxValue}`);r.validate?.(e)}})}function $({readMethod:e,writeMethod:t,...r}){return A({...r,read:t=>t[e](),write:(e,r)=>r[t](BigInt(e)),validate:e=>{const t=BigInt(e);if(t<0||t>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${t}. Expected value in range 0-${r.maxValue}`);r.validate?.(t)}})}g=new WeakMap,y=new WeakMap;class B extends TypeError{constructor(e,t){let r;const{message:n,explanation:i,...s}=e,{path:a}=e,o=0===a.length?n:`At path: ${a.join(".")} -- ${n}`;super(i??o),null!=i&&(this.cause=o),Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>r??(r=[e,...t()])}}function j(e){return"object"==typeof e&&null!=e}function M(e){return"symbol"==typeof e?e.toString():"string"==typeof e?JSON.stringify(e):`${e}`}function z(e,t,r,n){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:i,branch:s}=t,{type:a}=r,{refinement:o,message:c=`Expected a value of type \`${a}\`${o?` with refinement \`${o}\``:""}, but received: \`${M(n)}\``}=e;return{value:n,type:a,refinement:o,key:i[i.length-1],path:i,branch:s,...e,message:c}}function*U(e,t,r,n){var i;j(i=e)&&"function"==typeof i[Symbol.iterator]||(e=[e]);for(const i of e){const e=z(i,t,r,n);e&&(yield e)}}function*O(e,t,r={}){const{path:n=[],branch:i=[e],coerce:s=!1,mask:a=!1}=r,o={path:n,branch:i};if(s&&(e=t.coercer(e,o),a&&"type"!==t.type&&j(t.schema)&&j(e)&&!Array.isArray(e)))for(const r in e)void 0===t.schema[r]&&delete e[r];let c="valid";for(const n of t.validator(e,o))n.explanation=r.message,c="not_valid",yield[n,void 0];for(let[u,d,l]of t.entries(e,o)){const t=O(d,l,{path:void 0===u?n:[...n,u],branch:void 0===u?i:[...i,d],coerce:s,mask:a,message:r.message});for(const r of t)r[0]?(c=null!=r[0].refinement?"not_refined":"not_valid",yield[r[0],void 0]):s&&(d=r[1],void 0===u?e=d:e instanceof Map?e.set(u,d):e instanceof Set?e.add(d):j(e)&&(void 0!==d||u in e)&&(e[u]=d))}if("not_valid"!==c)for(const n of t.refiner(e,o))n.explanation=r.message,c="not_refined",yield[n,void 0];"valid"===c&&(yield[void 0,e])}class N{constructor(e){const{type:t,schema:r,validator:n,refiner:i,coercer:s=e=>e,entries:a=function*(){}}=e;this.type=t,this.schema=r,this.entries=a,this.coercer=s,this.validator=n?(e,t)=>U(n(e,t),t,this,e):()=>[],this.refiner=i?(e,t)=>U(i(e,t),t,this,e):()=>[]}assert(e,t){return function(e,t,r){const n=V(e,t,{message:r});if(n[0])throw n[0]}(e,this,t)}create(e,t){return _(e,this,t)}is(e){return C(e,this)}mask(e,t){return function(e,t,r){const n=V(e,t,{coerce:!0,mask:!0,message:r});if(n[0])throw n[0];return n[1]}(e,this,t)}validate(e,t={}){return V(e,this,t)}}function _(e,t,r){const n=V(e,t,{coerce:!0,message:r});if(n[0])throw n[0];return n[1]}function C(e,t){return!V(e,t)[0]}function V(e,t,r={}){const n=O(e,t,r),i=function(e){const{done:t,value:r}=e.next();return t?void 0:r}(n);return i[0]?[new B(i[0],(function*(){for(const e of n)e[0]&&(yield e[0])})),void 0]:[void 0,i[1]]}function P(e,t){return new N({type:e,schema:null,validator:t})}function q(){return P("any",(()=>!0))}function R(e){return new N({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[r,n]of t.entries())yield[r,n,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||`Expected an array value, but received: ${M(e)}`})}function W(){return P("integer",(e=>"number"==typeof e&&!isNaN(e)&&Number.isInteger(e)||`Expected an integer, but received: ${M(e)}`))}function L(e){const t=M(e),r=typeof e;return new N({type:"literal",schema:"string"===r||"number"===r||"boolean"===r?e:null,validator:r=>r===e||`Expected the literal \`${t}\`, but received: ${M(r)}`})}function D(e){const t=e?Object.keys(e):[],r=P("never",(()=>!1));return new N({type:"object",schema:e||null,*entries(n){if(e&&j(n)){const i=new Set(Object.keys(n));for(const r of t)i.delete(r),yield[r,n[r],e[r]];for(const e of i)yield[e,n[e],r]}},validator:e=>j(e)||`Expected an object, but received: ${M(e)}`,coercer:e=>j(e)?{...e}:e})}function G(e){return new N({...e,validator:(t,r)=>void 0===t||e.validator(t,r),refiner:(t,r)=>void 0===t||e.refiner(t,r)})}function F(){return P("string",(e=>"string"==typeof e||`Expected a string, but received: ${M(e)}`))}function K(e){const t=e.map((e=>e.type)).join(" | ");return new N({type:"union",schema:null,coercer(t){for(const r of e){const[e,n]=r.validate(t,{coerce:!0});if(!e)return n}return t},validator(r,n){const i=[];for(const t of e){const[...e]=O(r,t,n),[s]=e;if(!s[0])return[];for(const[t]of e)t&&i.push(t)}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${M(r)}`,...i]}})}const J=class{constructor(t){if(this.types=new Map,this.counter=0,t instanceof J)return this.schema=t.schema,void(this.types=new Map(t.types));if(this.schema=t,this.registerAddressType(J.ADDRESS,t.addressLength,t.addressEncoding),this.registerVectorType(t.vectorType),t.types&&t.types.structs)for(let e of Object.keys(t.types.structs))this.registerStructType(e,t.types.structs[e]);if(t.types&&t.types.enums)for(let e of Object.keys(t.types.enums))this.registerEnumType(e,t.types.enums[e]);if(t.types&&t.types.aliases)for(let e of Object.keys(t.types.aliases))this.registerAlias(e,t.types.aliases[e]);!1!==t.withPrimitives&&function(t){t.registerType(H.U8,(function(e,t){return e.write8(t)}),(function(e){return e.read8()}),(e=>e<256)),t.registerType(H.U16,(function(e,t){return e.write16(t)}),(function(e){return e.read16()}),(e=>e<65536)),t.registerType(H.U32,(function(e,t){return e.write32(t)}),(function(e){return e.read32()}),(e=>e<=4294967296n)),t.registerType(H.U64,(function(e,t){return e.write64(t)}),(function(e){return e.read64()})),t.registerType(H.U128,(function(e,t){return e.write128(t)}),(function(e){return e.read128()})),t.registerType(H.U256,(function(e,t){return e.write256(t)}),(function(e){return e.read256()})),t.registerType(H.BOOL,(function(e,t){return e.write8(t)}),(function(e){return"1"===e.read8().toString(10)})),t.registerType(H.STRING,(function(e,t){return e.writeVec(Array.from(t),((e,t)=>e.write8(t.charCodeAt(0))))}),(function(e){return e.readVec((e=>e.read8())).map((e=>String.fromCharCode(Number(e)))).join("")}),(e=>!0)),t.registerType(H.HEX,(function(e,t){return e.writeVec(Array.from(o(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return c(new Uint8Array(t))})),t.registerType(H.BASE58,(function(e,t){return e.writeVec(Array.from(a(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return s(new Uint8Array(t))})),t.registerType(H.BASE64,(function(t,r){return t.writeVec(Array.from(e(r)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return n(new Uint8Array(t))}))}(this)}tempKey(){return"bcs-struct-"+ ++this.counter}ser(e,t,r){if("string"==typeof e||Array.isArray(e)){const{name:n,params:i}=this.parseTypeName(e);return this.getTypeInterface(n).encode(this,t,r,i)}if("object"==typeof e){const n=this.tempKey();return new J(this).registerStructType(n,e).ser(n,t,r)}throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(e)}`)}de(t,r,n){if("string"==typeof r){if(!n)throw new Error("To pass a string to `bcs.de`, specify encoding");r=function(t,r){switch(r){case"base58":return a(t);case"base64":return e(t);case"hex":return o(t);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}(r,n)}if("string"==typeof t||Array.isArray(t)){const{name:e,params:n}=this.parseTypeName(t);return this.getTypeInterface(e).decode(this,r,n)}if("object"==typeof t){const e=new J(this),i=this.tempKey();return e.registerStructType(i,t).de(i,r,n)}throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(t)}`)}hasType(e){return this.types.has(e)}registerAlias(e,t){return this.types.set(e,t),this}registerType(e,t,r,n=()=>!0){const{name:i,params:s}=this.parseTypeName(e);return this.types.set(i,{encode(e,t,r,n){const i=s.reduce(((e,t,r)=>Object.assign(e,{[t]:n[r]})),{});return this._encodeRaw.call(e,new h(r),t,n,i)},decode(e,t,r){const n=s.reduce(((e,t,n)=>Object.assign(e,{[t]:r[n]})),{});return this._decodeRaw.call(e,new d(t),r,n)},_encodeRaw(e,r,s,a){if(n(r))return t.call(this,e,r,s,a);throw new Error(`Validation failed for type ${i}, data: ${r}`)},_decodeRaw(e,t,n){return r.call(this,e,t,n)}}),this}registerBcsType(e,t){return this.registerType(e,((e,r,n)=>{const i=n.map((e=>new E({name:String(e),write:(t,r)=>{const{name:i,params:s}=this.parseTypeName(e),a=this.getTypeInterface(i),o=s.reduce(((e,t,r)=>Object.assign(e,{[t]:n[r]})),{});return a._encodeRaw.call(this,r,t,s,o)},read:()=>{throw new Error("Not implemented")}})));return t(...i).write(r,e),e}),((e,r)=>{const n=r.map((e=>new E({name:String(e),write:(e,t)=>{throw new Error("Not implemented")},read:t=>{const{name:n,params:i}=this.parseTypeName(e),s=this.getTypeInterface(n),a=i.reduce(((e,t,n)=>Object.assign(e,{[t]:r[n]})),{});return s._decodeRaw.call(this,t,i,a)}})));return t(...n).read(e)})),this}registerAddressType(t,r,i="hex"){switch(i){case"base64":return this.registerType(t,(function(t,r){return e(r).reduce(((e,t)=>e.write8(t)),t)}),(function(e){return n(e.readBytes(r))}));case"hex":return this.registerType(t,(function(e,t){return o(t).reduce(((e,t)=>e.write8(t)),e)}),(function(e){return c(e.readBytes(r))}));default:throw new Error("Unsupported encoding! Use either hex or base64")}}registerVectorType(e){let{name:t,params:r}=this.parseTypeName(e);if(r.length>1)throw new Error("Vector can have only one type parameter; got "+t);return this.registerType(e,(function(t,r,n,i){return t.writeVec(r,((t,r)=>{let s=n[0];if(!s)throw new Error(`Incorrect number of type parameters passed a to vector '${e}'`);let{name:a,params:o}=this.parseTypeName(s);if(this.hasType(a))return this.getTypeInterface(a)._encodeRaw.call(this,t,r,o,i);if(!(a in i))throw new Error(`Unable to find a matching type definition for ${a} in vector; make sure you passed a generic`);let{name:c,params:u}=this.parseTypeName(i[a]);return this.getTypeInterface(c)._encodeRaw.call(this,t,r,u,i)}))}),(function(t,r,n){return t.readVec((t=>{let i=r[0];if(!i)throw new Error(`Incorrect number of type parameters passed to a vector '${e}'`);let{name:s,params:a}=this.parseTypeName(i);if(this.hasType(s))return this.getTypeInterface(s)._decodeRaw.call(this,t,a,n);if(!(s in n))throw new Error(`Unable to find a matching type definition for ${s} in vector; make sure you passed a generic`);let{name:o,params:c}=this.parseTypeName(n[s]);return this.getTypeInterface(o)._decodeRaw.call(this,t,c,n)}))}))}registerStructType(e,t){for(let e in t){let r=this.tempKey(),n=t[e];Array.isArray(n)||"string"==typeof n||(t[e]=r,this.registerStructType(r,n))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,(function(e,t,a,o){if(!t||t.constructor!==Object)throw new Error(`Expected ${i} to be an Object, got: ${t}`);if(a.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${a.length}`);for(let c of n){if(!(c in t))throw new Error(`Struct ${i} requires field ${c}:${r[c]}`);const{name:n,params:u}=this.parseTypeName(r[c]);if(s.includes(n)){const r=s.indexOf(n);let{name:u,params:d}=this.parseTypeName(a[r]);if(this.hasType(u)){this.getTypeInterface(u)._encodeRaw.call(this,e,t[c],d,o);continue}if(!(u in o))throw new Error(`Unable to find a matching type definition for ${u} in ${i}; make sure you passed a generic`);let{name:l,params:h}=this.parseTypeName(o[u]);this.getTypeInterface(l)._encodeRaw.call(this,e,t[c],h,o)}else this.getTypeInterface(n)._encodeRaw.call(this,e,t[c],u,o)}return e}),(function(e,t,a){if(t.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${t.length}`);let o={};for(let c of n){const{name:n,params:u}=this.parseTypeName(r[c]);if(s.includes(n)){const r=s.indexOf(n);let{name:u,params:d}=this.parseTypeName(t[r]);if(this.hasType(u)){o[c]=this.getTypeInterface(u)._decodeRaw.call(this,e,d,a);continue}if(!(u in a))throw new Error(`Unable to find a matching type definition for ${u} in ${i}; make sure you passed a generic`);let{name:l,params:h}=this.parseTypeName(a[u]);o[c]=this.getTypeInterface(l)._decodeRaw.call(this,e,h,a)}else o[c]=this.getTypeInterface(n)._decodeRaw.call(this,e,u,a)}return o}))}registerEnumType(e,t){for(let e in t){let r=this.tempKey(),n=t[e];null===n||Array.isArray(n)||"string"==typeof n||(t[e]=r,this.registerStructType(r,n))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,(function(e,t,a,o){if(!t)throw new Error(`Unable to write enum "${i}", missing data.\nReceived: "${t}"`);if("object"!=typeof t)throw new Error(`Incorrect data passed into enum "${i}", expected object with properties: "${n.join(" | ")}".\nReceived: "${JSON.stringify(t)}"`);let c=Object.keys(t)[0];if(void 0===c)throw new Error(`Empty object passed as invariant of the enum "${i}"`);let u=n.indexOf(c);if(-1===u)throw new Error(`Unknown invariant of the enum "${i}", allowed values: "${n.join(" | ")}"; received "${c}"`);let d=n[u],l=r[d];if(e.write8(u),null===l)return e;let h=s.indexOf(l),p=-1===h?l:a[h];{let{name:r,params:n}=this.parseTypeName(p);return this.getTypeInterface(r)._encodeRaw.call(this,e,t[c],n,o)}}),(function(e,t,a){let o=e.readULEB(),c=n[o],u=r[c];if(-1===o)throw new Error(`Decoding type mismatch, expected enum "${i}" invariant index, received "${o}"`);if(null===u)return{[c]:!0};let d=s.indexOf(u),l=-1===d?u:t[d];{let{name:t,params:r}=this.parseTypeName(l);return{[c]:this.getTypeInterface(t)._decodeRaw.call(this,e,r,a)}}}))}getTypeInterface(e){let t=this.types.get(e);if("string"==typeof t){let e=[];for(;"string"==typeof t;){if(e.includes(t))throw new Error(`Recursive definition found: ${e.join(" -> ")} -> ${t}`);e.push(t),t=this.types.get(t)}}if(void 0===t)throw new Error(`Type ${e} is not registered`);return t}parseTypeName(e){if(Array.isArray(e)){let[t,...r]=e;return{name:t,params:r}}if("string"!=typeof e)throw new Error(`Illegal type passed as a name of the type: ${e}`);let[t,r]=this.schema.genericSeparators||["<",">"],n=e.indexOf(t),i=Array.from(e).reverse().indexOf(r);if(-1===n&&-1===i)return{name:e,params:[]};if(-1===n||-1===i)throw new Error(`Unclosed generic in name '${e}'`);return{name:e.slice(0,n),params:l(e.slice(n+1,e.length-i-1),this.schema.genericSeparators)}}};let H=J;H.U8="u8",H.U16="u16",H.U32="u32",H.U64="u64",H.U128="u128",H.U256="u256",H.BOOL="bool",H.VECTOR="vector",H.ADDRESS="address",H.STRING="string",H.HEX="hex-string",H.BASE58="base58-string",H.BASE64="base64-string";const X={u8:e=>I({name:"u8",readMethod:"read8",writeMethod:"write8",size:1,maxValue:255,...e}),u16:e=>I({name:"u16",readMethod:"read16",writeMethod:"write16",size:2,maxValue:65535,...e}),u32:e=>I({name:"u32",readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...e}),u64:e=>$({name:"u64",readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...e}),u128:e=>$({name:"u128",readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...e}),u256:e=>$({name:"u256",readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...e}),bool:e=>A({name:"bool",size:1,read:e=>1===e.read8(),write:(e,t)=>t.write8(e?1:0),...e,validate:t=>{if(e?.validate?.(t),"boolean"!=typeof t)throw new TypeError("Expected boolean, found "+typeof t)}}),uleb128:e=>function({serialize:e,...t}){const r=new E({...t,serialize:e,write:(e,t)=>{for(const n of r.serialize(e).toBytes())t.write8(n)}});return r}({name:"uleb128",read:e=>e.readULEB(),serialize:e=>Uint8Array.from(u(e)),...e}),bytes:(e,t)=>A({name:`bytes[${e}]`,size:e,read:t=>t.readBytes(e),write:(t,r)=>{for(let n=0;n<e;n++)r.write8(t[n]??0)},...t,validate:r=>{if(t?.validate?.(r),!("length"in r))throw new TypeError("Expected array, found "+typeof r);if(r.length!==e)throw new TypeError(`Expected array of length ${e}, found ${r.length}`)}}),string:e=>function({toBytes:e,fromBytes:t,...r}){return new E({...r,read:e=>{const r=e.readULEB(),n=e.readBytes(r);return t(n)},write:(t,r)=>{const n=e(t);r.writeULEB(n.length);for(let e=0;e<n.length;e++)r.write8(n[e])},serialize:t=>{const r=e(t),n=u(r.length),i=new Uint8Array(n.length+r.length);return i.set(n,0),i.set(r,n.length),i},validate:e=>{if("string"!=typeof e)throw new TypeError(`Invalid ${r.name} value: ${e}. Expected string`);r.validate?.(e)}})}({name:"string",toBytes:e=>(new TextEncoder).encode(e),fromBytes:e=>(new TextDecoder).decode(e),...e}),fixedArray:(e,t,r)=>new E({name:`${t.name}[${e}]`,read:r=>{const n=new Array(e);for(let i=0;i<e;i++)n[i]=t.read(r);return n},write:(e,r)=>{for(const n of e)t.write(n,r)},...r,validate:t=>{if(r?.validate?.(t),!("length"in t))throw new TypeError("Expected array, found "+typeof t);if(t.length!==e)throw new TypeError(`Expected array of length ${e}, found ${t.length}`)}}),option:e=>X.enum(`Option<${e.name}>`,{None:null,Some:e}).transform({input:e=>null==e?{None:!0}:{Some:e},output:e=>"Some"in e?e.Some:null}),vector:(e,t)=>new E({name:`vector<${e.name}>`,read:t=>{const r=t.readULEB(),n=new Array(r);for(let i=0;i<r;i++)n[i]=e.read(t);return n},write:(t,r)=>{r.writeULEB(t.length);for(const n of t)e.write(n,r)},...t,validate:e=>{if(t?.validate?.(e),!("length"in e))throw new TypeError("Expected array, found "+typeof e)}}),tuple:(e,t)=>new E({name:`(${e.map((e=>e.name)).join(", ")})`,serializedSize:t=>{let r=0;for(let n=0;n<e.length;n++){const i=e[n].serializedSize(t[n]);if(null==i)return null;r+=i}return r},read:t=>{const r=[];for(const n of e)r.push(n.read(t));return r},write:(t,r)=>{for(let n=0;n<e.length;n++)e[n].write(t[n],r)},...t,validate:r=>{if(t?.validate?.(r),!Array.isArray(r))throw new TypeError("Expected array, found "+typeof r);if(r.length!==e.length)throw new TypeError(`Expected array of length ${e.length}, found ${r.length}`)}}),struct(e,t,r){const n=Object.entries(t);return new E({name:e,serializedSize:e=>{let t=0;for(const[r,i]of n){const n=i.serializedSize(e[r]);if(null==n)return null;t+=n}return t},read:e=>{const t={};for(const[r,i]of n)t[r]=i.read(e);return t},write:(e,t)=>{for(const[r,i]of n)i.write(e[r],t)},...r,validate:e=>{if(r?.validate?.(e),"object"!=typeof e||null==e)throw new TypeError("Expected object, found "+typeof e)}})},enum(e,t,r){const n=Object.entries(t);return new E({name:e,read:e=>{const t=e.readULEB(),[r,i]=n[t];return{[r]:i?.read(e)??!0}},write:(e,t)=>{const[r,i]=Object.entries(e)[0];for(let e=0;e<n.length;e++){const[s,a]=n[e];if(s===r)return t.writeULEB(e),void a?.write(i,t)}},...r,validate:e=>{if(r?.validate?.(e),"object"!=typeof e||null==e)throw new TypeError("Expected object, found "+typeof e);const n=Object.keys(e);if(1!==n.length)throw new TypeError(`Expected object with one key, found ${n.length}`);const[i]=n;if(!Object.hasOwn(t,i))throw new TypeError(`Invalid enum variant ${i}`)}})},map:(e,t)=>X.vector(X.tuple([e,t])).transform({name:`Map<${e.name}, ${t.name}>`,input:e=>[...e.entries()],output:e=>{const t=new Map;for(const[r,n]of e)t.set(r,n);return t}}),generic:(e,t)=>(...e)=>t(...e).transform({name:`${t.name}<${e.map((e=>e.name)).join(", ")}>`,input:e=>e,output:e=>e}),lazy:e=>function(e){let t=null;function r(){return t||(t=e()),t}return new E({name:"lazy",read:e=>r().read(e),serializedSize:e=>r().serializedSize(e),write:(e,t)=>r().write(e,t),serialize:(e,t)=>r().serialize(e,t).toBytes()})}(e)};function Z(e){try{return 32===a(e).length}catch(e){return!1}}function Q(e){return function(e){return/^(0x|0X)?[a-fA-F0-9]+$/.test(e)&&e.length%2==0}(e)&&32===function(e){return/^(0x|0X)/.test(e)?(e.length-2)/2:e.length/2}(e)}function Y(e){return Q(e)}function ee(e,t=!1){let r=e.toLowerCase();return!t&&r.startsWith("0x")&&(r=r.slice(2)),`0x${r.padStart(64,"0")}`}function te(e,t=!1){return ee(e,t)}const re=/^vector<(.+)>$/,ne=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class ie{static parseFromStr(e,t=!1){if("address"===e)return{address:null};if("bool"===e)return{bool:null};if("u8"===e)return{u8:null};if("u16"===e)return{u16:null};if("u32"===e)return{u32:null};if("u64"===e)return{u64:null};if("u128"===e)return{u128:null};if("u256"===e)return{u256:null};if("signer"===e)return{signer:null};const r=e.match(re);if(r)return{vector:ie.parseFromStr(r[1],t)};const n=e.match(ne);if(n)return{struct:{address:t?ee(n[1]):n[1],module:n[2],name:n[3],typeParams:void 0===n[5]?[]:ie.parseStructTypeArgs(n[5],t)}};throw new Error(`Encountered unexpected token when parsing type args for ${e}`)}static parseStructTypeArgs(e,t=!1){return l(e).map((e=>ie.parseFromStr(e,t)))}static tagToString(e){if("bool"in e)return"bool";if("u8"in e)return"u8";if("u16"in e)return"u16";if("u32"in e)return"u32";if("u64"in e)return"u64";if("u128"in e)return"u128";if("u256"in e)return"u256";if("address"in e)return"address";if("signer"in e)return"signer";if("vector"in e)return`vector<${ie.tagToString(e.vector)}>`;if("struct"in e){const t=e.struct,r=t.typeParams.map(ie.tagToString).join(", ");return`${t.address}::${t.module}::${t.name}${r?`<${r}>`:""}`}throw new Error("Invalid TypeTag")}}const se=new H({genericSeparators:["<",">"],vectorType:"vector",addressLength:32,addressEncoding:"hex",types:{enums:{"Option<T>":{None:null,Some:"T"}}}});function ae(e){return X.u64({name:"unsafe_u64",...e}).transform({input:e=>e,output:e=>Number(e)})}function oe(e){return e.transform({input:e=>({[e.kind]:e}),output:e=>{const t=Object.keys(e)[0];return{kind:t,...e[t]}}})}const ce=X.bytes(32).transform({input:e=>"string"==typeof e?o(ee(e)):e,output:e=>ee(c(e))}),ue=X.vector(X.u8()).transform({name:"ObjectDigest",input:e=>a(e),output:e=>s(new Uint8Array(e))}),de=X.struct("SuiObjectRef",{objectId:ce,version:X.u64(),digest:ue}),le=X.struct("SharedObjectRef",{objectId:ce,initialSharedVersion:X.u64(),mutable:X.bool()}),he=X.enum("ObjectArg",{ImmOrOwned:de,Shared:le,Receiving:de}),pe=X.enum("CallArg",{Pure:X.vector(X.u8()),Object:he,ObjVec:X.vector(he)}),fe=X.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:X.lazy((()=>fe)),struct:X.lazy((()=>Se)),u16:null,u32:null,u256:null}),me=oe(X.enum("Argument",{GasCoin:null,Input:X.struct("Input",{index:X.u16()}),Result:X.struct("Result",{index:X.u16()}),NestedResult:X.struct("NestedResult",{index:X.u16(),resultIndex:X.u16()})})),ge=X.struct("ProgrammableMoveCall",{package:ce,module:X.string(),function:X.string(),type_arguments:X.vector(fe),arguments:X.vector(me)}).transform({input:e=>{const[t,r,n]=e.target.split("::"),i=e.typeArguments.map((e=>ie.parseFromStr(e,!0)));return{package:ee(t),module:r,function:n,type_arguments:i,arguments:e.arguments}},output:e=>({target:[e.package,e.module,e.function].join("::"),arguments:e.arguments,typeArguments:e.type_arguments.map(ie.tagToString)})}),ye=oe(X.enum("Transaction",{MoveCall:ge,TransferObjects:X.struct("TransferObjects",{objects:X.vector(me),address:me}),SplitCoins:X.struct("SplitCoins",{coin:me,amounts:X.vector(me)}),MergeCoins:X.struct("MergeCoins",{destination:me,sources:X.vector(me)}),Publish:X.struct("Publish",{modules:X.vector(X.vector(X.u8())),dependencies:X.vector(ce)}),MakeMoveVec:X.struct("MakeMoveVec",{type:(Pe=fe,X.enum("Option",{None:null,Some:Pe})),objects:X.vector(me)}),Upgrade:X.struct("Upgrade",{modules:X.vector(X.vector(X.u8())),dependencies:X.vector(ce),packageId:ce,ticket:me})})),we=X.struct("ProgrammableTransaction",{inputs:X.vector(pe),transactions:X.vector(ye)}),be=X.enum("TransactionKind",{ProgrammableTransaction:we,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),ve=X.enum("TransactionExpiration",{None:null,Epoch:ae()}),Se=X.struct("StructTag",{address:ce,module:X.string(),name:X.string(),typeParams:X.vector(fe)}),Te=X.struct("GasData",{payment:X.vector(de),owner:ce,price:X.u64(),budget:X.u64()}),Ee=X.struct("TransactionDataV1",{kind:be,sender:ce,gasData:Te,expiration:ve}),xe=X.enum("TransactionData",{V1:Ee}),ke=X.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),Ae=X.enum("IntentVersion",{V0:null}),Ie=X.enum("AppId",{Sui:null}),$e=X.struct("Intent",{scope:ke,version:Ae,appId:Ie}),Be=X.generic(["T"],(e=>X.struct("IntentMessage<T>",{intent:$e,value:e}))),je=X.enum("CompressedSignature",{ED25519:X.fixedArray(64,X.u8()),Secp256k1:X.fixedArray(64,X.u8()),Secp256r1:X.fixedArray(64,X.u8()),ZkLogin:X.vector(X.u8())}),Me=X.enum("PublicKey",{ED25519:X.fixedArray(32,X.u8()),Secp256k1:X.fixedArray(33,X.u8()),Secp256r1:X.fixedArray(33,X.u8()),ZkLogin:X.vector(X.u8())}),ze=X.struct("MultiSigPkMap",{pubKey:Me,weight:X.u8()}),Ue=X.struct("MultiSigPublicKey",{pk_map:X.vector(ze),threshold:X.u16()}),Oe=X.struct("MultiSig",{sigs:X.vector(je),bitmap:X.u16(),multisig_pk:Ue}),Ne=X.vector(X.u8()).transform({input:t=>"string"==typeof t?e(t):t,output:e=>n(new Uint8Array(e))}),_e=X.struct("SenderSignedTransaction",{intentMessage:Be(xe),txSignatures:X.vector(Ne)}),Ce=X.vector(_e,{name:"SenderSignedData"}),Ve={...X,U8:X.u8(),U16:X.u16(),U32:X.u32(),U64:X.u64(),U128:X.u128(),U256:X.u256(),ULEB128:X.uleb128(),Bool:X.bool(),String:X.string(),Address:ce,Argument:me,CallArg:pe,CompressedSignature:je,GasData:Te,MultiSig:Oe,MultiSigPkMap:ze,MultiSigPublicKey:Ue,ObjectArg:he,ObjectDigest:ue,ProgrammableMoveCall:ge,ProgrammableTransaction:we,PublicKey:Me,SenderSignedData:Ce,SenderSignedTransaction:_e,SharedObjectRef:le,StructTag:Se,SuiObjectRef:de,Transaction:ye,TransactionData:xe,TransactionDataV1:Ee,TransactionExpiration:ve,TransactionKind:be,TypeTag:fe,ser:se.ser.bind(se),de:se.de.bind(se),getTypeInterface:se.getTypeInterface.bind(se),hasType:se.hasType.bind(se),parseTypeName:se.parseTypeName.bind(se),registerAddressType:se.registerAddressType.bind(se),registerAlias:se.registerAlias.bind(se),registerBcsType:se.registerBcsType.bind(se),registerEnumType:se.registerEnumType.bind(se),registerStructType:se.registerStructType.bind(se),registerType:se.registerType.bind(se),types:se.types};var Pe;se.registerBcsType("utf8string",(()=>X.string({name:"utf8string"}))),se.registerBcsType("unsafe_u64",(()=>ae())),se.registerBcsType("enumKind",(e=>oe(e))),[ce,me,pe,je,Te,Oe,ze,Ue,he,ue,ge,we,Me,Ce,le,Se,de,ye,xe,Ee,ve,be,fe].forEach((e=>{se.registerBcsType(e.name,(()=>e))})),BigInt(1e9);const qe="0x1",Re=(te("0x6"),te("0x5"),D({digest:F(),objectId:F(),version:K([P("number",(e=>"number"==typeof e&&!isNaN(e)||`Expected a number, but received: ${M(e)}`)),F(),P("bigint",(e=>"bigint"==typeof e))])})),We=K([D({ImmOrOwned:Re}),D({Shared:D({objectId:F(),initialSharedVersion:K([W(),F()]),mutable:P("boolean",(e=>"boolean"==typeof e))})}),D({Receiving:Re})]),Le=D({Pure:R(W())}),De=D({Object:We}),Ge=K([Le,De]),Fe=function(e,t){return{Pure:Array.from(e instanceof Uint8Array?e:(r=e,r&&"object"==typeof r&&!0===r[x]?e.toBytes():Ve.ser(t,e,{maxSize:1/0}).toBytes()))};var r},Ke=({objectId:e,digest:t,version:r})=>({Object:{ImmOrOwned:{digest:t,version:r,objectId:ee(e)}}}),Je=({objectId:e,mutable:t,initialSharedVersion:r})=>({Object:{Shared:{mutable:t,initialSharedVersion:r,objectId:ee(e)}}}),He=({objectId:e,digest:t,version:r})=>({Object:{Receiving:{digest:t,version:r,objectId:ee(e)}}});function Xe(e){return"object"==typeof e&&"MutableReference"in e?e.MutableReference:void 0}function Ze(e){return"object"==typeof e&&"Reference"in e?e.Reference:void 0}function Qe(e){if("object"==typeof e&&"Struct"in e)return e;const t=Ze(e),r=Xe(e);return"object"==typeof t&&"Struct"in t?t:"object"==typeof r&&"Struct"in r?r:void 0}const Ye={address:"0x2",module:"object",name:"ID"},et={address:qe,module:"ascii",name:"String"},tt={address:qe,module:"string",name:"String"},rt={address:qe,module:"option",name:"Option"},nt=(e,t)=>e.address===t.address&&e.module===t.module&&e.name===t.name;function it(e,t){if(void 0!==t&&typeof t!==e)throw new Error(`Expect ${t} to be ${e}, received ${typeof t}`)}const st=["Address","Bool","U8","U16","U32","U64","U128","U256"];function at(e,t){if("string"==typeof e&&st.includes(e)){if(e in["U8","U16","U32","U64","U128","U256"])it("number",t);else if("Bool"===e)it("boolean",t);else if("Address"===e&&(it("string",t),t&&!Q(t)))throw new Error("Invalid Sui Address");return e.toLowerCase()}if("string"==typeof e)throw new Error(`Unknown pure normalized type ${JSON.stringify(e,null,2)}`);if("Vector"in e){if((void 0===t||"string"==typeof t)&&"U8"===e.Vector)return"string";if(void 0!==t&&!Array.isArray(t))throw new Error(`Expect ${t} to be a array, received ${typeof t}`);const r=at(e.Vector,t?t[0]:void 0);if(void 0===r)return;return`vector<${r}>`}if("Struct"in e){if(nt(e.Struct,et))return"string";if(nt(e.Struct,tt))return"utf8string";if(nt(e.Struct,Ye))return"address";if(nt(e.Struct,rt))return at({Vector:e.Struct.typeArguments[0]},t)}}const ot=K([D({kind:L("Input"),index:W(),value:G(q()),type:G(L("object"))}),D({kind:L("Input"),index:W(),value:G(q()),type:L("pure")})]),ct=K([ot,D({kind:L("GasCoin")}),D({kind:L("Result"),index:W()}),D({kind:L("NestedResult"),index:W(),resultIndex:W()})]),ut=D({kind:L("MoveCall"),target:P("target",F().validator),typeArguments:R(F()),arguments:R(ct)}),dt=D({kind:L("TransferObjects"),objects:R(ct),address:ct}),lt=D({kind:L("SplitCoins"),coin:ct,amounts:R(ct)}),ht=D({kind:L("MergeCoins"),destination:ct,sources:R(ct)}),pt=D({kind:L("MakeMoveVec"),type:G((mt=F(),gt=P("unknown",(()=>!0)),ft=new N({type:"record",schema:null,*entries(e){if(j(e))for(const t in e){const r=e[t];yield[t,t,mt],yield[t,r,gt]}},validator:e=>j(e)||`Expected an object, but received: ${M(e)}`}),K([D({None:K([L(!0),L(null)])}),D({Some:ft})]))),objects:R(ct)});var ft,mt,gt;K([...[ut,dt,lt,ht,D({kind:L("Publish"),modules:R(R(W())),dependencies:R(F())}),D({kind:L("Upgrade"),modules:R(R(W())),dependencies:R(F()),packageId:F(),ticket:ct}),pt]]);var yt,wt,bt,vt=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},St=(e,t,r)=>(vt(e,t,"read from private field"),r?r.call(e):t.get(e)),Tt=(e,t,r)=>(vt(e,t,"access private method"),r);const Et={maxPureArgumentSize:16384,maxTxGas:5e10,maxGasObjects:256,maxTxSizeBytes:131072};function xt(e){if(!e.client)throw new Error("No provider passed to Transaction#build, but transaction data was not sufficient to build offline.");return e.client}const kt=Symbol.for("@mysten/transaction"),At={maxTxGas:"max_tx_gas",maxGasObjects:"max_gas_payment_objects",maxTxSizeBytes:"max_tx_size_bytes",maxPureArgumentSize:"max_pure_argument_size"};yt=new WeakMap,new WeakSet,new WeakSet,wt=new WeakSet,bt=function(e,{protocolConfig:t,limits:r}){if(r&&"number"==typeof r[e])return r[e];if(!t)return Et[e];const n=t?.attributes[At[e]];if(!n)throw new Error(`Missing expected protocol config: "${At[e]}"`);const i="u64"in n?n.u64:"u32"in n?n.u32:n.f64;if(!i)throw new Error(`Unexpected protocol config value found for: "${At[e]}"`);return Number(i)},new WeakSet,new WeakSet,new WeakSet,new WeakSet,new WeakSet;const It=/^(?:[a-z0-9][a-z0-9-]{0,62}(?:\.[a-z0-9][a-z0-9-]{0,62})*)?@[a-z0-9][a-z0-9-]{0,62}$/i,$t=/^(?:[a-z0-9][a-z0-9-]{0,62}\.)+sui$/i,Bt={"-32700":"ParseError","-32600":"InvalidRequest","-32601":"MethodNotFound","-32602":"InvalidParams","-32603":"InternalError"};class jt extends Error{}class Mt extends jt{constructor(e,t){super(e),this.code=t,this.type=Bt[t]??"ServerError"}}class zt extends jt{constructor(e,t,r){super(e),this.status=t,this.statusText=r}}var Ut,Ot,Nt,_t,Ct,Vt,Pt,qt,Rt,Wt,Lt=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},Dt=(e,t,r)=>(Lt(e,t,"read from private field"),r?r.call(e):t.get(e)),Gt=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},Ft=(e,t,r,n)=>(Lt(e,t,"write to private field"),n?n.call(e,r):t.set(e,r),r),Kt=(e,t,r)=>(Lt(e,t,"access private method"),r);const Jt={WebSocketConstructor:"undefined"!=typeof WebSocket?WebSocket:void 0,callTimeout:3e4,reconnectTimeout:3e3,maxReconnects:5};class Ht{constructor(e,t={}){if(Gt(this,Pt),Gt(this,Rt),Gt(this,Ut,0),Gt(this,Ot,0),Gt(this,Nt,null),Gt(this,_t,null),Gt(this,Ct,new Set),Gt(this,Vt,new Map),this.endpoint=e,this.options={...Jt,...t},!this.options.WebSocketConstructor)throw new Error("Missing WebSocket constructor");this.endpoint.startsWith("http")&&(this.endpoint=function(e){const t=new URL(e);return t.protocol=t.protocol.replace("http","ws"),t.toString()}(this.endpoint))}async makeRequest(e,t){const r=await Kt(this,Pt,qt).call(this);return new Promise(((n,i)=>{Ft(this,Ut,Dt(this,Ut)+1),Dt(this,Vt).set(Dt(this,Ut),{resolve:n,reject:i,timeout:setTimeout((()=>{Dt(this,Vt).delete(Dt(this,Ut)),i(new Error(`Request timeout: ${e}`))}),this.options.callTimeout)}),r.send(JSON.stringify({jsonrpc:"2.0",id:Dt(this,Ut),method:e,params:t}))})).then((({error:e,result:t})=>{if(e)throw new Mt(e.message,e.code);return t}))}async subscribe(e){const t=new Xt(e);return Dt(this,Ct).add(t),await t.subscribe(this),()=>t.unsubscribe(this)}}Ut=new WeakMap,Ot=new WeakMap,Nt=new WeakMap,_t=new WeakMap,Ct=new WeakMap,Vt=new WeakMap,Pt=new WeakSet,qt=function(){return Dt(this,_t)||Ft(this,_t,new Promise((e=>{Dt(this,Nt)?.close(),Ft(this,Nt,new this.options.WebSocketConstructor(this.endpoint)),Dt(this,Nt).addEventListener("open",(()=>{Ft(this,Ot,0),e(Dt(this,Nt))})),Dt(this,Nt).addEventListener("close",(()=>{var e,t;(e=this,t=Ot,{set _(r){Ft(e,t,r,undefined)},get _(){return Dt(e,t,undefined)}})._++,Dt(this,Ot)<=this.options.maxReconnects&&setTimeout((()=>{Kt(this,Rt,Wt).call(this)}),this.options.reconnectTimeout)})),Dt(this,Nt).addEventListener("message",(({data:e})=>{let t;try{t=JSON.parse(e)}catch(t){return void console.error(new Error(`Failed to parse RPC message: ${e}`,{cause:t}))}if("id"in t&&null!=t.id&&Dt(this,Vt).has(t.id)){const{resolve:e,timeout:r}=Dt(this,Vt).get(t.id);clearTimeout(r),e(t)}else if("params"in t){const{params:e}=t;Dt(this,Ct).forEach((t=>{t.subscriptionId===e.subscription&&e.subscription===t.subscriptionId&&t.onMessage(e.result)}))}}))}))),Dt(this,_t)},Rt=new WeakSet,Wt=async function(){return Dt(this,Nt)?.close(),Ft(this,_t,null),Promise.allSettled([...Dt(this,Ct)].map((e=>e.subscribe(this))))};class Xt{constructor(e){this.subscriptionId=null,this.subscribed=!1,this.input=e}onMessage(e){this.subscribed&&this.input.onMessage(e)}async unsubscribe(e){const{subscriptionId:t}=this;return this.subscribed=!1,null!=t&&(this.subscriptionId=null,e.makeRequest(this.input.unsubscribe,[t]))}async subscribe(e){this.subscriptionId=null,this.subscribed=!0;const t=await e.makeRequest(this.input.method,this.input.params);this.subscribed&&(this.subscriptionId=t)}}var Zt,Qt,Yt,er,tr,rr=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},nr=(e,t,r)=>(rr(e,t,"read from private field"),r?r.call(e):t.get(e)),ir=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},sr=(e,t,r,n)=>(rr(e,t,"write to private field"),n?n.call(e,r):t.set(e,r),r);class ar{constructor(e){ir(this,er),ir(this,Zt,0),ir(this,Qt,void 0),ir(this,Yt,void 0),sr(this,Qt,e)}fetch(e,t){const r=nr(this,Qt).fetch??globalThis.fetch;if(!r)throw new Error("The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport.");return r(e,t)}async request(e){sr(this,Zt,nr(this,Zt)+1);const t=await this.fetch(nr(this,Qt).rpc?.url??nr(this,Qt).url,{method:"POST",headers:{"Content-Type":"application/json","Client-Sdk-Type":"typescript","Client-Sdk-Version":"0.54.1","Client-Target-Api-Version":"1.25.0",...nr(this,Qt).rpc?.headers},body:JSON.stringify({jsonrpc:"2.0",id:nr(this,Zt),method:e.method,params:e.params})});if(!t.ok)throw new zt(`Unexpected status code: ${t.status}`,t.status,t.statusText);const r=await t.json();if("error"in r&&null!=r.error)throw new Mt(r.error.message,r.error.code);return r.result}async subscribe(e){const t=await(r=er,n=tr,rr(this,r,"access private method"),n).call(this).subscribe(e);var r,n;return async()=>!!await t()}}Zt=new WeakMap,Qt=new WeakMap,Yt=new WeakMap,er=new WeakSet,tr=function(){if(!nr(this,Yt)){const e=nr(this,Qt).WebSocketConstructor??globalThis.WebSocket;if(!e)throw new Error("The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport.");sr(this,Yt,new Ht(nr(this,Qt).websocket?.url??nr(this,Qt).url,{WebSocketConstructor:e,...nr(this,Qt).websocket}))}return nr(this,Yt)};const or=Symbol.for("@mysten/SuiClient");class cr{get[or](){return!0}constructor(e){this.transport=e.transport??new ar({url:e.url})}async getRpcApiVersion(){return(await this.transport.request({method:"rpc.discover",params:[]})).info.version}async getCoins(e){if(!e.owner||!Q(ee(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getCoins",params:[e.owner,e.coinType,e.cursor,e.limit]})}async getAllCoins(e){if(!e.owner||!Q(ee(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllCoins",params:[e.owner,e.cursor,e.limit]})}async getBalance(e){if(!e.owner||!Q(ee(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getBalance",params:[e.owner,e.coinType]})}async getAllBalances(e){if(!e.owner||!Q(ee(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllBalances",params:[e.owner]})}async getCoinMetadata(e){return await this.transport.request({method:"suix_getCoinMetadata",params:[e.coinType]})}async getTotalSupply(e){return await this.transport.request({method:"suix_getTotalSupply",params:[e.coinType]})}async call(e,t){return await this.transport.request({method:e,params:t})}async getMoveFunctionArgTypes(e){return await this.transport.request({method:"sui_getMoveFunctionArgTypes",params:[e.package,e.module,e.function]})}async getNormalizedMoveModulesByPackage(e){return await this.transport.request({method:"sui_getNormalizedMoveModulesByPackage",params:[e.package]})}async getNormalizedMoveModule(e){return await this.transport.request({method:"sui_getNormalizedMoveModule",params:[e.package,e.module]})}async getNormalizedMoveFunction(e){return await this.transport.request({method:"sui_getNormalizedMoveFunction",params:[e.package,e.module,e.function]})}async getNormalizedMoveStruct(e){return await this.transport.request({method:"sui_getNormalizedMoveStruct",params:[e.package,e.module,e.struct]})}async getOwnedObjects(e){if(!e.owner||!Q(ee(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getOwnedObjects",params:[e.owner,{filter:e.filter,options:e.options},e.cursor,e.limit]})}async getObject(e){if(!e.id||!Y(te(e.id)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"sui_getObject",params:[e.id,e.options]})}async tryGetPastObject(e){return await this.transport.request({method:"sui_tryGetPastObject",params:[e.id,e.version,e.options]})}async multiGetObjects(e){if(e.ids.forEach((e=>{if(!e||!Y(te(e)))throw new Error(`Invalid Sui Object id ${e}`)})),e.ids.length!==new Set(e.ids).size)throw new Error(`Duplicate object ids in batch call ${e.ids}`);return await this.transport.request({method:"sui_multiGetObjects",params:[e.ids,e.options]})}async queryTransactionBlocks(e){return await this.transport.request({method:"suix_queryTransactionBlocks",params:[{filter:e.filter,options:e.options},e.cursor,e.limit,"descending"===(e.order||"descending")]})}async getTransactionBlock(e){if(!Z(e.digest))throw new Error("Invalid Transaction digest");return await this.transport.request({method:"sui_getTransactionBlock",params:[e.digest,e.options]})}async multiGetTransactionBlocks(e){if(e.digests.forEach((e=>{if(!Z(e))throw new Error(`Invalid Transaction digest ${e}`)})),e.digests.length!==new Set(e.digests).size)throw new Error(`Duplicate digests in batch call ${e.digests}`);return await this.transport.request({method:"sui_multiGetTransactionBlocks",params:[e.digests,e.options]})}async executeTransactionBlock(e){return await this.transport.request({method:"sui_executeTransactionBlock",params:["string"==typeof e.transactionBlock?e.transactionBlock:n(e.transactionBlock),Array.isArray(e.signature)?e.signature:[e.signature],e.options,e.requestType]})}async signAndExecuteTransactionBlock({transactionBlock:e,signer:t,...r}){let n;e instanceof Uint8Array?n=e:(e.setSenderIfNotSet(t.toSuiAddress()),n=await e.build({client:this}));const{signature:i,bytes:s}=await t.signTransactionBlock(n);return this.executeTransactionBlock({transactionBlock:s,signature:i,...r})}async getTotalTransactionBlocks(){const e=await this.transport.request({method:"sui_getTotalTransactionBlocks",params:[]});return BigInt(e)}async getReferenceGasPrice(){const e=await this.transport.request({method:"suix_getReferenceGasPrice",params:[]});return BigInt(e)}async getStakes(e){if(!e.owner||!Q(ee(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getStakes",params:[e.owner]})}async getStakesByIds(e){return e.stakedSuiIds.forEach((e=>{if(!e||!Y(te(e)))throw new Error(`Invalid Sui Stake id ${e}`)})),await this.transport.request({method:"suix_getStakesByIds",params:[e.stakedSuiIds]})}async getLatestSuiSystemState(){return await this.transport.request({method:"suix_getLatestSuiSystemState",params:[]})}async queryEvents(e){return await this.transport.request({method:"suix_queryEvents",params:[e.query,e.cursor,e.limit,"descending"===(e.order||"descending")]})}async subscribeEvent(e){return this.transport.subscribe({method:"suix_subscribeEvent",unsubscribe:"suix_unsubscribeEvent",params:[e.filter],onMessage:e.onMessage})}async subscribeTransaction(e){return this.transport.subscribe({method:"suix_subscribeTransaction",unsubscribe:"suix_unsubscribeTransaction",params:[e.filter],onMessage:e.onMessage})}async devInspectTransactionBlock(e){let t;if((r=e.transactionBlock)&&"object"==typeof r&&!0===r[kt])e.transactionBlock.setSenderIfNotSet(e.sender),t=n(await e.transactionBlock.build({client:this,onlyTransactionKind:!0}));else if("string"==typeof e.transactionBlock)t=e.transactionBlock;else{if(!(e.transactionBlock instanceof Uint8Array))throw new Error("Unknown transaction block format.");t=n(e.transactionBlock)}var r;return await this.transport.request({method:"sui_devInspectTransactionBlock",params:[e.sender,t,e.gasPrice?.toString(),e.epoch]})}async dryRunTransactionBlock(e){return await this.transport.request({method:"sui_dryRunTransactionBlock",params:["string"==typeof e.transactionBlock?e.transactionBlock:n(e.transactionBlock)]})}async getDynamicFields(e){if(!e.parentId||!Y(te(e.parentId)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"suix_getDynamicFields",params:[e.parentId,e.cursor,e.limit]})}async getDynamicFieldObject(e){return await this.transport.request({method:"suix_getDynamicFieldObject",params:[e.parentId,e.name]})}async getLatestCheckpointSequenceNumber(){const e=await this.transport.request({method:"sui_getLatestCheckpointSequenceNumber",params:[]});return String(e)}async getCheckpoint(e){return await this.transport.request({method:"sui_getCheckpoint",params:[e.id]})}async getCheckpoints(e){return await this.transport.request({method:"sui_getCheckpoints",params:[e.cursor,e?.limit,e.descendingOrder]})}async getCommitteeInfo(e){return await this.transport.request({method:"suix_getCommitteeInfo",params:[e?.epoch]})}async getNetworkMetrics(){return await this.transport.request({method:"suix_getNetworkMetrics",params:[]})}async getAddressMetrics(){return await this.transport.request({method:"suix_getLatestAddressMetrics",params:[]})}async getEpochMetrics(e){return await this.transport.request({method:"suix_getEpochMetrics",params:[e?.cursor,e?.limit,e?.descendingOrder]})}async getAllEpochAddressMetrics(e){return await this.transport.request({method:"suix_getAllEpochAddressMetrics",params:[e?.descendingOrder]})}async getEpochs(e){return await this.transport.request({method:"suix_getEpochs",params:[e?.cursor,e?.limit,e?.descendingOrder]})}async getMoveCallMetrics(){return await this.transport.request({method:"suix_getMoveCallMetrics",params:[]})}async getCurrentEpoch(){return await this.transport.request({method:"suix_getCurrentEpoch",params:[]})}async getValidatorsApy(){return await this.transport.request({method:"suix_getValidatorsApy",params:[]})}async getChainIdentifier(){const e=await this.getCheckpoint({id:"0"});return c(a(e.digest).slice(0,4))}async resolveNameServiceAddress(e){return await this.transport.request({method:"suix_resolveNameServiceAddress",params:[e.name]})}async resolveNameServiceNames({format:e="dot",...t}){const{nextCursor:r,hasNextPage:n,data:i}=await this.transport.request({method:"suix_resolveNameServiceNames",params:[t.address,t.cursor,t.limit]});return{hasNextPage:n,nextCursor:r,data:i.map((t=>function(e,t="at"){const r=e.toLowerCase();let n;if(r.includes("@")){if(!It.test(r))throw new Error(`Invalid SuiNS name ${e}`);const[t,i]=r.split("@");n=[...t?t.split("."):[],i]}else{if(!$t.test(r))throw new Error(`Invalid SuiNS name ${e}`);n=r.split(".").slice(0,-1)}return"dot"===t?`${n.join(".")}.sui`:`${n.slice(0,-1).join(".")}@${n[n.length-1]}`}(t,e)))}}async getProtocolConfig(e){return await this.transport.request({method:"sui_getProtocolConfig",params:[e?.version]})}async waitForTransactionBlock({signal:e,timeout:t=6e4,pollInterval:r=2e3,...n}){const i=AbortSignal.timeout(t),s=new Promise(((e,t)=>{i.addEventListener("abort",(()=>t(i.reason)))}));for(s.catch((()=>{}));!i.aborted;){e?.throwIfAborted();try{return await this.getTransactionBlock(n)}catch(e){await Promise.race([new Promise((e=>setTimeout(e,r))),s])}}throw i.throwIfAborted(),new Error("Unexpected error while waiting for transaction block.")}}var ur=r(364);const dr=ur("0123456789abcdefghijklmnopqrstuvwxyz"),lr=Ve.fixedArray(32,Ve.u8()).transform({input:e=>o(e),output:e=>c(Uint8Array.from(e))}),hr=Ve.struct("Color",{r:Ve.u8(),g:Ve.u8(),b:Ve.u8()}),pr=Ve.struct("Sanmover",{id:lr,color:hr,sides:Ve.u8()});function fr(){const e=document.createElement("h2");e.innerText="sorry, not a valid sanmover",document.getElementById("picture").appendChild(e)}!function(){const t=function(e){const t=new URL(e),r=t.hostname.split(".");if(3===r.length||2===r.length&&"localhost"===r[1]){const e="/"==t.pathname?"/index.html":function(e){return e.endsWith("/")?e.slice(0,-1):e}(t.pathname);return{subdomain:r[0],path:e}}return null}(window.location.origin);if(!t)return void fr();const r=function(e){const t="0x"+c(dr.decode(e.toLowerCase()));return console.log("obtained object id: ",t,Y(t),Q(t)),Y(t)?t:null}(t.subdomain);r?async function(t){const r=new cr({url:"https://fullnode.testnet.sui.io:443"}),n=await r.getObject({id:t,options:{showBcs:!0,showType:!0}});if(console.log("sanmover object:",n),n.data&&n.data.bcs&&"moveObject"===n.data.bcs.dataType&&"0xf16cd34e4a52cf9188ea2cbcb2f07103e0c54bf1c160a8f8c12c170f1ca70f80::sanmove::Sanmover"===n.data.type){let t=pr.parse(e(n.data.bcs.bcsBytes));return console.log("struct",t),t}return null}(r).then((e=>{if(!e)return void fr();console.log("sanmover: ",e),async function(e){const t=e.sides,r=2*Math.PI/t,n=-Math.PI/2,i=function(e){return`${e.r}, ${e.g}, ${e.b}`}(e.color);document.documentElement.style.setProperty("--color",`${i}`);const s=document.createElementNS("http://www.w3.org/2000/svg","svg");s.setAttribute("width","200"),s.setAttribute("height","200"),s.setAttribute("id","sanmove"),s.setAttribute("xmlns","http://www.w3.org/2000/svg"),document.getElementById("picture").appendChild(s);const a=document.createElementNS("http://www.w3.org/2000/svg","polygon");a.setAttribute("fill",`rgb(${i})`);let o="";for(let e=0;e<t;e++)o+=`${100+50*Math.cos(r*e+n)},${100+50*Math.sin(r*e+n)} `;a.setAttribute("points",o);const c=document.createElementNS("http://www.w3.org/2000/svg","animateTransform");c.setAttribute("attributeName","transform"),c.setAttribute("begin","0s"),c.setAttribute("dur","10s"),c.setAttribute("type","rotate"),c.setAttribute("from","0 100 100"),c.setAttribute("to","360 100 100"),c.setAttribute("repeatCount","indefinite"),a.appendChild(c),s.appendChild(a)}(e);const t=document.createElement("h1");t.innerText="your NFT",document.getElementById("text").appendChild(t);const r=document.createElement("p");r.innerHTML="    .             </br>      NFT  .",document.getElementById("text").appendChild(r)})):fr()}()})()})();